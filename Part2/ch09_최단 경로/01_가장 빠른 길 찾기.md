# 최단 경로
* 길 찾기
* 최단 거리 알고리즘: 다익스트라, 플로이드 위셜, 밸만 포드

<br>
--------------------
--------------------

## 다익스트라 최단 경로 알고리즘
* 그래프에서 여러 개의 노드가 있을 때 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘
* 음의 간선이 없을 때 정상적으로 동작 (음의 간선: 음수의 값을 가지는 간선)
* GPS 소프트웨어의 기본 알고리즘
* 그리디 알고리즘으로 분류
* 매번 '가장 비용이 적은 노드'를 선택하여 임의의 과정을 반복
### 다익스트라 기본 원리
1) 출발 노드 설정
2) 최단 거리 테이블 초기화
3) 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택
4) 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신
5) 3, 4번 반복
### 방법1. 간단한 다익스트라 알고리즘
* 시간복잡도: O(V^2) (V: 노드의 개수)
```python
INF = int(1e9)

# 입력
n, m = map(int, input().split()) # 노드의 개수, 간선의 개수
start = int(input())             # 시작 노드 번호
graph = [[] for i in range(n+1)]
visited = [[0] * (n+1)]
distance = [INF] * (n+1)         # 최단 거리
for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a].append((b, c))

# 방문하지 않는 노드 중에서 가장 최단거리가 짧은 노드의 번호를 찾는 함수
def get_smallest_node():
    min_value = INF
    idx = 0
    for i in range(1, n+1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            idx = i
    return idx

# 다익스트라 함수
def dijkstra(start):
    # 시작 노드 초기화
    distance[start] = 0
    visited[start] = 1
    for i in graph[start]:
        distance[i[0]] = i[1]
    
    # 시작 노드를 제외한 n-1개의 노드에 대해 반복
    for i in range(n-1):
        now = get_smallest_node() # 현재 최단 거리가 가장 짧은 노드
        visited[now] = 1
        
        # 현재 노드와 연결된 다른 노드 확인
        for j in graph[now]:
            cost = distance[now] + j[1]
            if cost < distance[j[0]]:
                distance[j[0]] = cost

dijkstra(start)

# 출력
for i in range(1, n+1):
    if distance[i] == INF:
        print('INFINITY')
    else:
        print(distance[i])
```
### 방법2. 개선된 다익스트라 알고리즘
* 시간복잡도: O(ElogV) (V: 노드의 개수, E: 간선의 개수)
* 힙 자료구조
    * 우선순위 큐를 구현하기 위해 사용하는 자료구조
    * 최소힙: 값이 낮은 데이터가 가장 먼저 삭제
    * 최대힙: 값이 큰 데이터가 가장 먼저 삭제